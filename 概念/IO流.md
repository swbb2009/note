# IO流
1，学IO流之前，我们写的程序，都是在内存里自己跟自己玩。比如，你声明个变量，创建个数组，创建个集合，模拟一个链表，使用一些常用API，现在回想一下，是不是在只是自己在内存里玩一玩？计算机组成包括运算器，控制器，存储器，输入设备，输出设备。那么你前面的工作，仅仅够你的程序和内存以及CPU打打交道，如果你需要操作外部设备呢？比如键盘，显示器，再比如，最常见的外设：硬盘？甚至未来世界里的每家每户都有的机器人，“如何让你的程序和机器人进行交互呢？”
2，所以程序设计语言必须要提供程序与外部设备交互的方式，这就是IO框架的由来。我们需要和外部设备进行数据的交互。那么，计算机是通过什么和外部进行交互的呢？很简单就能想到：数据线。数据线里传播的是什么呢？一个词：比特流。比特就是bit的谐音，计算机中“位”的意思，代表0或1。1位或者1bit，就是一个0或一个1。但是，毕竟0或1不能表示什么，所以计算机更常见的基本单位是字节，也就是用8位0或1组成的一段数据。以上是对比特流的由来做一个简单地解释。上面两段话的意思，其实是为了下文做铺垫，帮助理解输入输出最重要的概念：方向性。输入还是输出，是相对于程序或者说相对于内存而言的。数据从外流到内存，就是输入（读），数据从内存出去，就是输出（写）。
3，既然计算机和外界进行信息的输入和输出交互，用的是比特流，那么很容易就能想到IO流名字的由来了。就是比喻输入输出的数据像流一样。我们可以这么认为，任何外部设备与内存之间输入输出的操作，都是需要输入输出流（IO流）来完成的，这里的IO流，指的就是比特流（或者称字节流）。这些外部设备，包括，键盘（标准输入设备），显示器（标准输出设备），音响，网络上另一台主机，甚至你玩游戏用的游戏手柄，以及各种各样的信号传感器，都可以叫做外部设备，和这些设备之间进行数据交互，显然不可能靠之前学习的那些数组，集合，常用类，String等等来完成。而是要靠和外界数据交换的类来完成。靠什么来进行数据交换，就是前面说的，比特流，或者说IO流类。
4，那么，既然要学习IO流，就得针对某一个输入输出设备来学习。哪种输入输出设备最重要同时也最常见？当然是硬盘。硬盘在这里的含义也可以理解为文件系统。（Java程序是运行在某操作系统平台上的应用软件JVM上的，实际上Java程序可见的并不是硬盘，而是操作系统提供的文件系统，因此此处可直接理解为文件系统）。因此，我们学习IO流的时候，基本上是学习的Java如何操作文件系统，除了文件系统，我们还能够了解Java操作标准输入输出设备，如http://System.in和System.out。
5，知道了学习的方向，是要使用Java操作文件系统，那么首先要学习的就是文件的表示，即File类。然后，我们要操作做文件，虽然我们大部分操作都是操作文件系统，但是要明白IO流的概念不仅仅局限在操作文件上，前面我已经提到了，我们的编程语言是要能操作所有的输入输出，因此，API提供了两个顶层抽象类，用来表示操作所有的输出输出：InputStream，OutputStream。并且，这两个类表示字节的输入输出，因为输入输出的本质是字节流。这里注意体会一句话“字节流是最最基本的流”，这句话的由来就是因为计算机底层传递的就是字节。那么，当我们要操作文件的时候，就需要具体的对文件系统操作的IO实现类，于是我们需要学习FileInputStream和FileOutputStream，它们是文件输入输出字节流。这里之所以FileInputStream/OutputStream作为子类出现，按照面向对象思想理解就是，将来还有别的字节流来操作别的设备（比如万一将来需要操作机器人，那么或许就会再来个RobotInputStream和RobotOutputStream）
6，学了文件IO字节流之后，我们会发现有时候用起来没那么高效，具体原因查看源代码。这里只提醒一句：带缓冲区的流对象，可以一次读一个缓冲区，不带缓冲区的流对象，只能一个字节一个字节的读，非常低效。所以又有了BufferedInputStream和BufferedOutputSteam。他们的用法是把字节流对象传入后再使用，也相当于把它俩套在了字节流的外面，给字节流装了个“外挂”，让基本字节流如虎添翼。
7，说到操作文件，就不得不提到文件的分类和编码格式。文件分为二进制文件和文本文件，二进制文件是用记事本打开后看不懂的，他们的编码格式是特殊的，比如pdf文件，exe文件。记事本打开后人能看懂的只有纯文本文件，我们处理文件（或者说处理任何的字节流），就免不了处理一些文本文件（或文本字节流）。如果是英语国家的人还好说，因为他们是用的常用字符用一张ASCII码表就能表示得出来，用一个字节就能表示一个字母。但是显然，对非英语国家的人来说，一个字节的大小无法表示他们所有的文字。因此，人们需要有能够处理字符的类，或者说这个类提供一个功能：就是把输入的字节转成字符，把要输出的字符转成计算机可以识别的字节。所以，你需要两个转换流：InputStreamReader和OutputStreamWriter。这两个类的作用分别是把字节流转成字符流，把字符流转成字节流。但是这两个流需要套在现成的字节流上才能使用，当中用到的设计模式也就是常说的装饰模式。当字节流被转成字符流之后，恭喜你，你可以不必操作字节流了，而是可以用人类的方式read和write各种“文字”。
8，还是回到文件系统，我们最常见的是和文件系统打交道，那么针对如此常见的用途，读取文本文件能不能用一种方便的方式呢？当然，大牛们替你想到并提供了。FileReader和FileWriter这两个流对象可以直接把文件转成读取、写入流。让你省去了创建字节流，再套上转换流的步骤。看看这类名起的，实际上很形象，xxxReader和xxxWriter，明摆着告诉你“阅读和书写”都是“人可以做的”也就是他们表示的是字符流。同理上面的InputStreamReader和OutputStreamWriter，表示的是把字节流转成人可读的，把字节流转成人可写的。因此他们的顶层抽象类：Reader和Writer，表示的是所有人类可读可写的字符流统称。
10，同上面说的缓冲区的作用，再把Reader和Writer做成高效的，就需要BufferedReader和BufferedWriter，把它们套在Reader和Writer上，就能实现高效的字符流。
11，讲到这里，IO流的大概思想已经说的的差不多了，是不是觉得之前混乱的那些类，现在知道他们的作用和设计思想以后，稍稍清晰了许多呢？可以简单的记，字节流是基础，字符流是对于字符功能的增强，操作文件系统有现成的FileXXX类。另外，还有许多类是“在内存里自己和自己玩的”比如ByteArrayReader/Writer，PipedWriter/Reader，以及其他带有某些功能的类，比如序列化流，比如数据输入输出流，等等。用到了再具体分析即可。